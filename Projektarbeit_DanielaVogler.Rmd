---
title: "Detektion von Sepsiserkrankungen in Intensivpatienten"
subtitle: "Projektarbeit im Zertifikatsprogramm \"Medical Data Science\""
author: "Daniela Vogler"
date: "`r format(Sys.time(), '%d.%m.%Y')`"
header-includes:
  \renewcommand{\tablename}{Tabelle}
  \renewcommand{\contentsname}{Inhalt}
output: 
  pdf_document:
  toc: true
  toc_depth: 2
  keep_tex: yes
  number_sections: true
fontsize: 12pt
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  include = FALSE,
  cache = TRUE,
  fig.pos = "H")
```

```{r requirements, include = FALSE}
library(tidyverse)
library(here)
library(kableExtra)
library(grid)
library(gridExtra)
library(reshape)
library(rpart)
library(rpart.plot)
library(party)
library(caret)
```

```{r session info, include = TRUE}
sessioninfo::platform_info()$version
subset(data.frame(sessioninfo::package_info()), attached==TRUE, 
       c(package, loadedversion))
```

```{r loading data}
data_complete <- read.csv(here("data/Dataset.csv"))

# Subsample ziehen, um die Datenmenge besser handhaben zu können
set.seed(12345)

n <- round(0.1*length(unique(data_complete$Patient_ID)))

data_sample_index <- data_complete %>% 
  distinct(Patient_ID) %>% 
  sample_n(n)

data_sample <- data_complete %>% 
  filter(Patient_ID %in% data_sample_index$Patient_ID)

var_info <- read.csv2(
  here("data/Datensatzbeschreibung.csv")
  )
```

```{r data structure}
summary(data_sample)
str(data_sample)

# Outcome pro Patient abspeichern
outcome <- data_sample %>% 
  group_by(Patient_ID) %>% 
  mutate(Sepsis = max(SepsisLabel)) %>% 
  ungroup() %>% 
  select(Patient_ID, Sepsis) %>% 
  unique()

table(outcome$Sepsis)
```
Es fallen zwei Fehler in den Daten auf:
1. FiO2 (inspiratorische Sauerstofffraktion) drückt einen Anteil aus und muss daher zwischen 0 und 1 liegen. Die Werte außerhalb dieses Bereichs werden daher entfernt.
2. HospAdmTime, die Zeit zwischen Hospitalisierung und Verlegung auf die Intensivstation, ist je nach Berechnung entweder positiv oder negativ, kann aber nicht sowohl positive als auch negative Werte annehmen, da niemand auf die Intensivstation verlegt werden kann, bevor er überhaupt im Krankenhaus ist. Es ist daher naheliegend, dass unterschiedliche Berechnungen (Aufnahmezeitpunkt_gesamt-Aufnahmezeitpunkt_Intensiv und Aufnahmezeitpunkt_Intensiv-Aufnahmezeitpunkt_gesamt) vorgenomen worden. Ich vereinheitliche hier auf positive Vorzeichen, da diese für die Interpretation geeigneter sind ("Zeit, die zwischen Aufnahme im Krankenhaus und Aufnahme auf der ITS vergangen ist").

```{r data cleaning}
data_sample %>%
  filter(FiO2 < 0 | FiO2 > 1)

data_sample %>%
  filter(HospAdmTime > 0) %>% 
  distinct(Patient_ID, HospAdmTime)

data_sample <- data_sample %>% 
  mutate(FiO2 = case_when(FiO2 >= 0 & FiO2 <= 1 ~ FiO2),
         HospAdmTime = case_when(HospAdmTime < 0 ~ -1*HospAdmTime,
                                 TRUE ~ HospAdmTime)
         )
```
```{r data preparation}
data_sample <- data_sample %>% 
  mutate(Gender = factor(Gender, levels = c(0, 1), labels = c("W", "M")),
         Unit1 = factor(Unit1, levels = c(0, 1), labels = c("nein", "ja")),
         Unit2 = factor(Unit2, levels = c(0, 1), labels = c("nein", "ja")),
         SepsisLabel = factor(SepsisLabel, levels = c(0, 1), 
                              labels = c("negativ", "positiv")
                              )
  )

outcome <- outcome %>% 
  mutate(Sepsis = factor(Sepsis, levels = c(0, 1),
                         labels = c("negativ", "positiv")
                         )
         )

# Zur weiteren Verwendung wird jedem Datensatz der Outcome über den gesamten # Zeitraum hinzugefügt
data_sample <- merge(data_sample, outcome, by = "Patient_ID")
```

```{r data correlation, fig.height=8, fig.width=12, message=TRUE, warning=FALSE}
data_sample %>% 
  select_if(is.numeric) %>%  
  select(-Patient_ID, -X) %>% 
  GGally::ggcorr(method = c("pairwise.complete.obs", "pearson"),
         label = TRUE, label_size =2, label_alpha = TRUE) + 
  labs(title = "Korrelationskoeffizienten nach Pearson")
```

Baum-basierte Methoden funktionieren auch bei starker Multikollinearität gut, da sukzessive einzelne Variablen für die Splits herangezogen werden. Liefert eine Variable keinen oder kaum Informationsgewinn, weil sie stark mit einer vorher bereits zum Split genutzten Variable korreliert, wird sie nicht verwendet. Daher müssen wir uns hier keine allzu großen Sorgen um die Korrelationen machen. Allerdings sollten starke Kollinearitäten später bei der Interpretation der Entscheidungskriterien berücksichtigt werden. Es ist möglich, dass nicht die eigentlich relevante Variable für einen Split herangezogen wird, sondern eine, die stark mit ihr korreliert ist.

Bei Variablen mit vollständigen linearen Zusammenhang (Korrelationskoeffizient +/- 1) scheint mir allerdings eine Variablenselektion dennoch angeraten.

Hour dient nur zur Information und soll nicht als Einflussvariable verwendet werden. Daher kann sie hier vernachlässigt werden.

```{r Bilirubin}
data_sample %>% 
  filter(is.na(Bilirubin_total) & !is.na(Bilirubin_direct)) %>% 
  summarize(n())

data_sample %>% 
  filter(is.na(Bilirubin_direct) & !is.na(Bilirubin_total)) %>% 
  summarize(n())
```
Da es nur sehr wenige Beobachtungen gibt, in denen das Gesamt-Bilirubin fehlt, aber direkts Bilirubin gemessen wurde, andersherum jedoch einige Beobachtungen existieren, die eine Messung des Gesamt-Bilirubins enthalten, abre keine des direkten Bilirubins, wird die Variable Bilirubin_direct aus dem Datensatz entfernt.

Hämoglobin- und Hämatokrit-Wert entsprechen einander ungefähr, weil die Erythrozyten den Großteil des Gesamtvolumens der Blutzellen ausmachen.

```{r Hct Hgb}
data_sample %>% 
  filter(is.na(Hct) & !is.na(Hgb)) %>% 
  summarize(n())

data_sample %>% 
  filter(is.na(Hgb) & !is.na(Hct)) %>% 
  summarize(n())
```

Ich entscheide daher auch hier nach Vollständigkeit der Beobachtungen und entferne die Variable Hgb aus dem Datensatz.

```{r variable selection}
data_sample <- data_sample %>% 
  select(-Bilirubin_direct, -Hgb)
```

```{r boxplots, include = TRUE, warning = FALSE, fig.height=8, fig.width=10, fig.cap="Boxplots der numerischen Einflussfaktoren"}
# Numerische Einflussfaktoren in Bezug zum temporärer Sepsisstatus
melt_sample <- data_sample %>% 
  select(-Gender, -Unit1, -Unit2, ) %>% 
  melt(., id.vars = c("Patient_ID", "X", "Hour", "SepsisLabel", "Sepsis"))

p <- ggplot(melt_sample, aes(factor(variable), value)) + 
  geom_boxplot(aes(fill = SepsisLabel)) + 
   labs(x = "", y = "") +
  facet_wrap(~variable, scale="free") +
  theme(strip.background = element_blank(), strip.text = element_blank())

p

rm(melt_sample, p)
```

Bei Betrachtung der Boxplots der möglichen numerischen Einflussfaktoren fällt keine Variable durch besonders deutliche Unterschiede zwischen Patienten mit und ohne Sepsis auf.

Da schwerwiegende Erkrankungen durchaus extreme medizinische Werte hervorbringen können, ist es schwierig festzulegen, wann Ausreißer Messfehler sind und daher aus der Betrachtung herausgenommen werden sollten. Zudem sind Baum-basierte Methoden robust gegenüber Ausreißern. Deshalb werden hier nur aus einer Variable wenige offensichtlich falsche Werte entfernt: 

```{r creating baseline dataset}
# Es sollen die Messwerte zur Stunde 1 verwendet werden, aber für den Outcome 
# ist der Gesamtzeitraum entscheidend
dataset1 <- data_sample %>% 
  filter(Hour == 1) %>% 
  select(-SepsisLabel)
```

```{r creating onset dataset}
# Es sollen die Beobachtungen zum Zeitpunkt des ersten positiven Labels verwendet
# werden, für Nicht-Sepsispatienten ein zufälliger Zeitpunkt
data_pos <- data_sample %>% 
  filter(SepsisLabel == "positiv") %>% 
  group_by(Patient_ID) %>% 
  mutate(ersteSepsisflag = min(Hour)) %>% 
  ungroup() %>% 
  filter(Hour == ersteSepsisflag) %>% 
  select(-ersteSepsisflag)

tmp_data_neg <- data_sample %>% 
  filter(Sepsis == "negativ") %>% 
  group_by(Patient_ID) %>% 
  summarize(max_Hour = max(Hour),
            selected_Hour = sample (c(1:max_Hour), size=1, replace =F)
            )

data_neg <- data_sample %>% 
  filter(Sepsis == "negativ") %>% 
  merge(., tmp_data_neg, by = "Patient_ID") %>% 
  filter(Hour == selected_Hour) %>% 
  select(-max_Hour, -selected_Hour)
  
  
dataset2 <- union_all(data_pos, data_neg) %>% 
  select(-SepsisLabel)

rm(data_pos, data_neg, tmp_data_neg)
```

```{r creating regression dataset}
# Anstelle der Vital- und Laborwerte sollen die patientenindividuellen Slopes verwendet werden. Wenn ein Patient eine Sepsis entwickelt, wird nur der Zeitraum bis zum ersten positiven Label betrachtet.

patient_model <- function(df) {
  if (sum(!is.na(df$yvalue)) < 2) NA 
  else lm(yvalue ~ Hour, data = df)$coeff[2]
  }

data_pos <- data_sample %>% 
  filter(SepsisLabel == "positiv") %>% 
  group_by(Patient_ID) %>% 
  mutate(ersteSepsisflag = min(Hour),
         ICULOS_end = min(ICULOS)) %>% 
  distinct(Patient_ID, ersteSepsisflag, ICULOS_end)

data_sub <- data_sample %>% 
  merge(., data_pos, by = "Patient_ID", all.x = TRUE) %>% 
  filter(Sepsis == "negativ" | 
           (ersteSepsisflag > 0 &  Hour <= ersteSepsisflag) 
         # für ersteSepsisFlag = 0 lässt sich keine Entwicklung aufzeigen
         ) %>% 
  group_by(Patient_ID) %>% 
  mutate(ICULOS = case_when(!is.na(ICULOS_end) ~ ICULOS_end,
                            TRUE ~ max(ICULOS))) %>% 
  ungroup() %>% 
  pivot_longer(cols = HR:Platelets, 
               names_to = "yvar", 
               values_to = "yvalue") %>% 
  mutate(yvar = paste("slope_", yvar)) # eindeutige Namen erzeugen

by_patient <- data_sub %>%
  group_by(Patient_ID, yvar) %>%
  nest() %>%
  mutate(slope = map(data, patient_model))%>%
  unnest(slope) %>%  
  select(-data) %>%
  pivot_wider(names_from = yvar, values_from = slope)

dataset3 <- data_sample %>% 
  distinct(Patient_ID, Age, Gender, Unit1, Unit2, HospAdmTime, Sepsis) %>%
  merge(by_patient, by = "Patient_ID", all = FALSE)

rm(by_patient, data_sub, data_pos)
```

```{r}
# caret::createDataPartition balanciert die Outcome-Varaible aus
#der train_index für Datensatz 1 kann auch für datensatz 2 genutzt werden (gleiche Patienten, gleicher Outcome)
train_index1 <- createDataPartition(dataset1$Sepsis, p=0.75, list = FALSE)

#Datensatz 3 benötigt einen anderen train_index, da hier nicht alle Patienten enthalten sind
train_index3 <- createDataPartition(dataset3$Sepsis, p=0.75, list = FALSE)

train1 <- dataset1[train_index1,]
test1  <- dataset1[-train_index1,]
train2 <- dataset2[train_index1,]
test2  <- dataset2[-train_index1,]
train3 <- dataset3[train_index3,]
test3  <- dataset3[-train_index3,]
```

```{r tree dataset2}
cart_ds2 <- rpart(Sepsis ~ .-X-Patient_ID-Hour-ICULOS , data = train2,
                  control = rpart.control(minsplit = 15,
                                          minbucket = 5, 
                                          cp = 0))

rpart.plot(cart_ds2)

cart_ds2_2 <- prune(cart_ds2, cp = 0.004)
rpart.plot(cart_ds2_2)


ci_ds2 <- ctree(Sepsis ~ ., 
               data = subset(train2, select = -c(X, Hour, Patient_ID))
               # data =train2
                )
ci_ds2
plot(ci_ds2)
table(predict(ci_ds2), train2$Sepsis)
```
```{r tree dataset1}
cart_ds1 <- rpart(Sepsis ~ .-X-Patient_ID-Hour , data = train1,
                  control = rpart.control(minsplit = 15,
                                          minbucket = 5, 
                                          cp = 0))

rpart.plot(cart_ds1)

cart_ds1_2 <- prune(cart_ds1, cp = 0.0025)
rpart.plot(cart_ds1_2)
```

```{r tree datase3}
cart_ds3 <- rpart(Sepsis ~ .-Patient_ID , data = train3,
                  control = rpart.control(minsplit = 15,
                                          minbucket = 5, 
                                          cp = 0))

rpart.plot(cart_ds3)

cart_ds3_2 <- prune(cart_ds3, cp = 0.01)
rpart.plot(cart_ds3_2)
```


```{r vars description, include = TRUE, echo = FALSE}
knitr::kable(var_info, booktabs = T,
             caption = "Datensatzbeschreibung (Variablen)") %>%
  kable_styling(latex_options = c("striped", "scale_down"),
                position = "center")
```