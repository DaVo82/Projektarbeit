---
title: "Detektion von Sepsiserkrankungen in Intensivpatienten"
subtitle: "Projektarbeit im Zertifikatsprogramm \"Medical Data Science\""
author: "Daniela Vogler"
date: "`r format(Sys.time(), '%d.%m.%Y')`"
header-includes:
  \renewcommand{\tablename}{Tabelle}
  \renewcommand{\contentsname}{Inhalt}
output: 
  pdf_document:
  toc: true
  toc_depth: 2
  keep_tex: yes
  number_sections: true
fontsize: 12pt
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  include = FALSE,
  cache = TRUE,
  fig.pos = "H")
```

```{r requirements, include = FALSE, cache = FALSE}
library(tidyverse)
library(here)
library(kableExtra)
library(grid)
library(gridExtra)
library(reshape)
library(rpart)
library(rpart.plot)
library(party)
library(rJava)
library(RWeka)
library(caret)
library(naniar)
```

```{r session info, include = TRUE}
sessioninfo::platform_info()$version
subset(data.frame(sessioninfo::package_info()), attached==TRUE, 
       c(package, loadedversion))
```

```{r loading data}
data_complete <- read.csv(here("data/Dataset.csv"))

# Subsample ziehen, um die Datenmenge besser handhaben zu können
set.seed(12345)

n <- round(0.1*length(unique(data_complete$Patient_ID)))

data_sample_index <- data_complete %>% 
  distinct(Patient_ID) %>% 
  sample_n(n)

data_sample <- data_complete %>% 
  filter(Patient_ID %in% data_sample_index$Patient_ID)

var_info <- read.csv2(
  here("data/Datensatzbeschreibung.csv")
  )
```

```{r data structure}
summary(data_sample)
str(data_sample)

# Outcome pro Patient abspeichern
outcome <- data_sample %>% 
  group_by(Patient_ID) %>% 
  mutate(Sepsis = max(SepsisLabel)) %>% 
  ungroup() %>% 
  select(Patient_ID, Sepsis) %>% 
  unique()

table(outcome$Sepsis)
```
Es fallen zwei Fehler in den Daten auf:
1. FiO2 (inspiratorische Sauerstofffraktion) drückt einen Anteil aus und muss daher zwischen 0 und 1 liegen. Die Werte außerhalb dieses Bereichs werden daher entfernt.
2. HospAdmTime, die Zeit zwischen Hospitalisierung und Verlegung auf die Intensivstation, ist je nach Berechnung entweder positiv oder negativ, kann aber nicht sowohl positive als auch negative Werte annehmen, da niemand auf die Intensivstation verlegt werden kann, bevor er überhaupt im Krankenhaus ist. Es ist daher naheliegend, dass unterschiedliche Berechnungen (Aufnahmezeitpunkt_gesamt-Aufnahmezeitpunkt_Intensiv und Aufnahmezeitpunkt_Intensiv-Aufnahmezeitpunkt_gesamt) vorgenomen worden. Ich vereinheitliche hier auf positive Vorzeichen, da diese für die Interpretation geeigneter sind ("Zeit, die zwischen Aufnahme im Krankenhaus und Aufnahme auf der ITS vergangen ist").

```{r data cleaning, cache = TRUE}
data_sample %>%
  filter(FiO2 < 0 | FiO2 > 1)

data_sample %>%
  filter(HospAdmTime > 0) %>% 
  distinct(Patient_ID, HospAdmTime)

data_sample <- data_sample %>% 
  mutate(FiO2 = case_when(FiO2 >= 0 & FiO2 <= 1 ~ FiO2),
         HospAdmTime = case_when(HospAdmTime < 0 ~ -1*HospAdmTime,
                                 TRUE ~ HospAdmTime)
         )
```
```{r data preparation, cache = TRUE}
data_sample <- data_sample %>% 
  mutate(Gender = factor(Gender, levels = c(0, 1), labels = c("W", "M")),
         Unit1 = factor(Unit1, levels = c(0, 1), labels = c("nein", "ja")),
         Unit2 = factor(Unit2, levels = c(0, 1), labels = c("nein", "ja")),
         SepsisLabel = factor(SepsisLabel, levels = c(0, 1), 
                              labels = c("negativ", "positiv")
                              )
  )

outcome <- outcome %>% 
  mutate(Sepsis = factor(Sepsis, levels = c(0, 1),
                         labels = c("negativ", "positiv")
                         )
         )

# Zur weiteren Verwendung wird jedem Datensatz der Outcome über den gesamten # Zeitraum hinzugefügt
data_sample <- merge(data_sample, outcome, by = "Patient_ID")
```

```{r data correlation, fig.height=8, fig.width=12, message=TRUE, warning=FALSE, include = TRUE, cache = TRUE}
data_sample %>% 
  select_if(is.numeric) %>%  
  select(-Patient_ID, -X) %>% 
  GGally::ggcorr(method = c("pairwise.complete.obs", "pearson"),
         label = TRUE, label_size =2, label_alpha = TRUE) + 
  labs(title = "Korrelationskoeffizienten nach Pearson")
```

Baum-basierte Methoden funktionieren auch bei starker Multikollinearität gut, da sukzessive einzelne Variablen für die Splits herangezogen werden. Liefert eine Variable keinen oder kaum Informationsgewinn, weil sie stark mit einer vorher bereits zum Split genutzten Variable korreliert, wird sie nicht verwendet. Daher müssen wir uns hier keine allzu großen Sorgen um die Korrelationen machen. Allerdings sollten starke Kollinearitäten später bei der Interpretation der Entscheidungskriterien berücksichtigt werden. Es ist möglich, dass nicht die eigentlich relevante Variable für einen Split herangezogen wird, sondern eine, die stark mit ihr korreliert ist.

Bei Variablen mit vollständigen linearen Zusammenhang (Korrelationskoeffizient +/- 1) scheint mir allerdings eine Variablenselektion dennoch angeraten.

Hour dient nur zur Information und soll nicht als Einflussvariable verwendet werden. Daher kann sie hier vernachlässigt werden.

```{r Bilirubin, cache = TRUE}
data_sample %>% 
  filter(is.na(Bilirubin_total) & !is.na(Bilirubin_direct)) %>% 
  summarize(n())

data_sample %>% 
  filter(is.na(Bilirubin_direct) & !is.na(Bilirubin_total)) %>% 
  summarize(n())
```
Da es nur sehr wenige Beobachtungen gibt, in denen das Gesamt-Bilirubin fehlt, aber direkts Bilirubin gemessen wurde, andersherum jedoch einige Beobachtungen existieren, die eine Messung des Gesamt-Bilirubins enthalten, abre keine des direkten Bilirubins, wird die Variable Bilirubin_direct aus dem Datensatz entfernt.

Hämoglobin- und Hämatokrit-Wert entsprechen einander ungefähr, weil die Erythrozyten den Großteil des Gesamtvolumens der Blutzellen ausmachen.

```{r Hct Hgb, cache = TRUE}
data_sample %>% 
  filter(is.na(Hct) & !is.na(Hgb)) %>% 
  summarize(n())

data_sample %>% 
  filter(is.na(Hgb) & !is.na(Hct)) %>% 
  summarize(n())
```

Ich entscheide daher auch hier nach Vollständigkeit der Beobachtungen und entferne die Variable Hgb aus dem Datensatz.

```{r variable selection, cache = TRUE}
data_sample <- data_sample %>% 
  select(-Bilirubin_direct, -Hgb)
```

```{r boxplots, include = TRUE, warning = FALSE, fig.height=8, fig.width=10, fig.cap="Boxplots der numerischen Einflussfaktoren", cache = TRUE}
# Numerische Einflussfaktoren in Bezug zum temporären Sepsisstatus
melt_sample <- data_sample %>% 
  select(-Gender, -Unit1, -Unit2, ) %>% 
  melt(., id.vars = c("Patient_ID", "X", "Hour", "SepsisLabel", "Sepsis"))

p <- ggplot(melt_sample, aes(factor(variable), value)) + 
  geom_boxplot(aes(fill = SepsisLabel)) + 
   labs(x = "", y = "") +
  facet_wrap(~variable, scale="free") +
  theme(strip.background = element_blank(), strip.text = element_blank())

p

rm(melt_sample, p)
```

Bei Betrachtung der Boxplots der möglichen numerischen Einflussfaktoren fällt keine Variable durch besonders deutliche Unterschiede zwischen Patienten mit und ohne Sepsis auf.

Da schwerwiegende Erkrankungen durchaus extreme medizinische Werte hervorbringen können, ist es schwierig festzulegen, wann Ausreißer Messfehler sind und daher aus der Betrachtung herausgenommen werden sollten. Zudem sind Baum-basierte Methoden robust gegenüber Ausreißern. Deshalb werden hier keine weiteren Beobachtungen entfernt.

Da Temperatur und Blutwerte häufig nur einmal tägöich bestimmt werden, macht es Sinn, diese bei fehlenden Eerten bis zu 24 Stunden fortzuschreiben (LOCF).

```{r LOCF imputation, warnings = FALSE}
data_sample_imputed <- data_sample %>% 
  pivot_longer(cols = Temp | BaseExcess:Platelets, 
               names_to = "var", 
               values_to = "value") %>% 
  group_by(Patient_ID, var) %>% 
  mutate(last_Hour = max(Hour[!is.na(value)]), 
         diff = Hour - last_Hour) %>% 
  fill(value) %>% 
  mutate(value = replace(value, which(diff > 24), NA)) %>% 
  select(-last_Hour, -diff) %>% 
  pivot_wider(names_from = var, values_from = value) %>% 
  relocate(Temp, .after = O2Sat) %>% 
  relocate(BaseExcess:Platelets, .after = EtCO2) %>% 
  as.data.frame()
```


```{r creating baseline dataset}
# Es sollen die Messwerte zur Stunde 1 verwendet werden, aber für den Outcome 
# ist der Gesamtzeitraum entscheidend
dataset1 <- data_sample_imputed %>% 
  filter(Hour == 1) %>% 
  select(-SepsisLabel)
```

```{r creating onset dataset}
# Es sollen die Beobachtungen zum Zeitpunkt des ersten positiven Labels verwendet
# werden, für Nicht-Sepsispatienten ein zufälliger Zeitpunkt
data_pos <- data_sample_imputed %>% 
  filter(SepsisLabel == "positiv") %>% 
  group_by(Patient_ID) %>% 
  mutate(ersteSepsisflag = min(Hour)) %>% 
  ungroup() %>% 
  filter(Hour == ersteSepsisflag) %>% 
  select(-ersteSepsisflag)

tmp_data_neg <- data_sample_imputed %>% 
  filter(Sepsis == "negativ") %>% 
  group_by(Patient_ID) %>% 
  summarize(max_Hour = max(Hour),
            selected_Hour = sample(c(1:max_Hour),
                                    size = 1, replace = F)
            )

data_neg <- data_sample_imputed %>% 
  filter(Sepsis == "negativ") %>% 
  merge(., tmp_data_neg, by = "Patient_ID") %>% 
  filter(Hour == selected_Hour) %>% 
  select(-max_Hour, -selected_Hour)
  
  
dataset2 <- union_all(data_pos, data_neg) %>% 
  select(-SepsisLabel) %>% 
  as.data.frame()

rm(data_pos, data_neg, tmp_data_neg)
```

```{r creating regression dataset}
# Anstelle der Vital- und Laborwerte sollen die patientenindividuellen Slopes verwendet werden. Wenn ein Patient eine Sepsis entwickelt, wird nur der Zeitraum bis zum ersten positiven Label betrachtet.

patient_model <- function(df) {
  if (sum(!is.na(df$yvalue)) < 2) NA 
  else lm(yvalue ~ Hour, data = df)$coeff[2]
  }

data_pos <- data_sample_imputed %>% 
  filter(SepsisLabel == "positiv") %>% 
  group_by(Patient_ID) %>% 
  mutate(ersteSepsisflag = min(Hour),
         ICULOS_end = min(ICULOS)) %>% 
  distinct(Patient_ID, ersteSepsisflag, ICULOS_end)

data_sub <- data_sample_imputed %>% 
  merge(., data_pos, by = "Patient_ID", all.x = TRUE) %>% 
  filter(Sepsis == "negativ" | 
           (ersteSepsisflag > 0 &  Hour <= ersteSepsisflag) 
         # für ersteSepsisFlag = 0 lässt sich keine Entwicklung aufzeigen
         ) %>% 
  group_by(Patient_ID) %>% 
  mutate(ICULOS = case_when(!is.na(ICULOS_end) ~ ICULOS_end,
                            TRUE ~ max(ICULOS))) %>% 
  ungroup() %>% 
  pivot_longer(cols = HR:Platelets, 
               names_to = "yvar", 
               values_to = "yvalue") %>% 
  mutate(yvar = paste("slope_", yvar, sep = "")) # eindeutige Namen erzeugen

by_patient <- data_sub %>%
  group_by(Patient_ID, yvar, ICULOS) %>% # damit ICULOS erhalten bleibt
  nest() %>%
  mutate(slope = map(data, patient_model)) %>%
  unnest(slope) %>%  
  select(-data) %>%
  pivot_wider(names_from = yvar, values_from = slope)

dataset3 <- data_sample_imputed %>% 
  distinct(Patient_ID, Age, Gender, Unit1, Unit2, HospAdmTime, Sepsis) %>%
  merge(by_patient, by = "Patient_ID", all = FALSE) %>% 
  select(Patient_ID, Sepsis, everything())

rm(by_patient, data_sub, data_pos)
```

```{r train and test sets}
# caret::createDataPartition balanciert die Outcome-Varaible aus
# der train_index für Datensatz 1 kann auch für Datensatz 2 genutzt werden (gleiche Patienten, gleicher Outcome)
train_index1 <- createDataPartition(dataset1$Sepsis, p = 0.75, list = FALSE)

#Datensatz 3 benötigt einen anderen train_index, da hier nicht alle Patienten enthalten sind
train_index3 <- createDataPartition(dataset3$Sepsis, p = 0.75, list = FALSE)

train1 <- dataset1[train_index1,]
test1  <- dataset1[-train_index1,]
train2 <- dataset2[train_index1,]
test2  <- dataset2[-train_index1,]
train3 <- dataset3[train_index3,]
test3  <- dataset3[-train_index3,]
```

```{r caret models control}
set.seed(12345)

ctrl <- trainControl(method = "cv", number = 5,
                     classProbs = TRUE,
                     summaryFunction = twoClassSummary,
                     sampling = "up")

#cp_grid <- expand.grid(cp = seq(0, 0.01, by = 0.0001))
```

```{r caret cart models ds1, include = TRUE}
set.seed(12345)

cart_ds1 <- train(x = train1[,4:41],
                  y = train1$Sepsis,
                  method = "rpart",
#                  tuneGrid = cp_grid,
                  metric = "ROC",
                  trControl = ctrl)

cart_ds1
rpart.plot(cart_ds1$finalModel, type = 5)
rpart.rules(cart_ds1$finalModel)

cart_ds1_Imp <- varImp(cart_ds1)
plot1 <- plot(cart_ds1_Imp, top = 20)

pred_cart_ds1 <- predict(cart_ds1, test1)
confusionMatrix(data = pred_cart_ds1, reference = test1$Sepsis, positive = "positiv")
```

```{r caret cart models ds1 preprocessed, include = TRUE}
set.seed(12345)

cart_proc_ds1 <- train(x = train1[,4:41],
                  y = train1$Sepsis,
                  preProcess = "medianImpute",
                  method = "rpart",
#                 tuneGrid = cp_grid,
                  metric = "ROC",
                  trControl = ctrl)

cart_proc_ds1
rpart.plot(cart_proc_ds1$finalModel, type = 5)

cart_proc_ds1_Imp <- varImp(cart_proc_ds1)
plot2 <- plot(cart_proc_ds1_Imp, top = 20)

grid.arrange(plot1, plot2, nrow = 1)

pred_cart_proc_ds1 <- predict(cart_proc_ds1, test1)
confusionMatrix(data = pred_cart_proc_ds1, reference = test1$Sepsis, positive = "positiv")
```

```{r caret cart models ds2, include = TRUE}
set.seed(12345)

cart_ds2 <- train(x = train2[,4:41],
                  y = train2$Sepsis,
                  method = "rpart",
#                 tuneGrid = cp_grid,
                  metric = "ROC",
                  trControl = ctrl)

cart_ds2
rpart.plot(cart_ds2$finalModel, type = 5)
rpart.rules(cart_ds2$finalModel)

cart_ds2_Imp <- varImp(cart_ds2)
plot1 <- plot(cart_ds2_Imp, top = 20)

pred_cart_ds2 <- predict(cart_ds2, test2)
confusionMatrix(data = pred_cart_ds2, reference = test2$Sepsis, positive = "positiv")
```


```{r caret cart models ds2 preprocessed, include = TRUE}
set.seed(12345)

cart_proc_ds2 <- train(x = train2[,4:41],
                  y = train2$Sepsis,
                  preProcess = "medianImpute",
                  method = "rpart",
#                 tuneGrid = cp_grid,
                  metric = "ROC",
                  trControl = ctrl)

cart_proc_ds2
rpart.plot(cart_proc_ds2$finalModel, type = 5)

cart_proc_ds2_Imp <- varImp(cart_proc_ds2)
plot2 <- plot(cart_proc_ds2_Imp, top = 20)

grid.arrange(plot1, plot2, nrow = 1)
# 
pred_cart_proc_ds2 <- predict(cart_proc_ds2, test2)
confusionMatrix(data = pred_cart_proc_ds2, reference = test2$Sepsis, positive = "positiv")
```
```{r caret cart models ds3, include = TRUE}
set.seed(12345)

cart_ds3 <- train(x = train3[,3:40],
                  y = train3$Sepsis,
                  method = "rpart",
#                 tuneGrid = cp_grid,
                  metric = "ROC",
                  trControl = ctrl)

cart_ds3
rpart.plot(cart_ds3$finalModel, type = 5)
rpart.rules(cart_ds3$finalModel)

cart_ds3_Imp <- varImp(cart_ds3)
plot1 <- plot(cart_ds3_Imp, top = 20)

pred_cart_ds3 <- predict(cart_ds3, test3)
confusionMatrix(data = pred_cart_ds3, reference = test3$Sepsis, positive = "positiv")
```

```{r caret cart models ds3 preprocessed, include = TRUE}
set.seed(12345)
# macht eigentlich keinen Sinn!!
cart_proc_ds3 <- train(x = train3[,3:40],
                  y = train3$Sepsis,
                  preProcess = "medianImpute",
                  method = "rpart",
#                 tuneGrid = cp_grid,
                  metric = "ROC",
                  trControl = ctrl)

cart_proc_ds3
rpart.plot(cart_proc_ds3$finalModel, type = 5)

cart_proc_ds3_Imp <- varImp(cart_proc_ds3)
plot2 <- plot(cart_proc_ds3_Imp, top = 20)

grid.arrange(plot1, plot2, nrow = 1)

pred_cart_proc_ds3 <- predict(cart_proc_ds3, test3)
confusionMatrix(data = pred_cart_proc_ds3, reference = test3$Sepsis, positive = "positiv")
```
```{r tune grid rf}
mtry_grid <-  expand.grid(mtry = seq(2,38,3))
```

```{r caret rf models ds1, include = TRUE, cache = FALSE}
set.seed(12345)

rf_proc_ds1 <- train(x = train1[,4:41],
                  y = train1$Sepsis,
                  preProcess = "medianImpute",
                  method = "rpart",
#                 tuneGrid = cp_grid,
                  metric = "ROC",
                  trControl = ctrl)

rf_proc_ds1

#Medianimputation der Testdaten findet automatisch statt
pred_rf_proc_ds1 <- predict(rf_proc_ds1$finalModel, test1, type = "class")
confusionMatrix(data = pred_rf_proc_ds1, reference = test1$Sepsis, positive = "positiv")

# Alternative: Imputation nach Breiman:

ds1_imputed <- rfImpute(train1$Sepsis ~ ., train1) %>% 
  dplyr::rename(Sepsis = `train1$Sepsis`) %>% 
  relocate(Sepsis, .after = ICULOS) 
  
rf_ds1 <- train(x = ds1_imputed[,4:41],
                  y = train1$Sepsis,
                  method = "rf",
                  tuneGrid = mtry_grid,
                  metric = "ROC",
                  trControl = ctrl)

rf_ds1

# Hier werden Tetsdaten nicht automatisch imputiert
pred_rf_ds1 <- predict(rf_ds1$finalModel, rfImpute(Sepsis ~., test1)[,-1], type = "class")
confusionMatrix(data = pred_rf_ds1, reference = test1$Sepsis, positive = "positiv")
```
```{r caret rf models ds2, include = TRUE, cache = FALSE}
set.seed(12345)

rf_proc_ds2 <- train(x = train2[,4:41],
                  y = train2$Sepsis,
                  preProcess = "medianImpute",
                  method = "rpart",
#                 tuneGrid = cp_grid,
                  metric = "ROC",
                  trControl = ctrl)

rf_proc_ds2

#Medianimputation der Testdaten findet automatisch statt
pred_rf_proc_ds2 <- predict(rf_proc_ds2$finalModel, test2, type = "class")
confusionMatrix(data = pred_rf_proc_ds2, reference = test2$Sepsis, positive = "positiv")

# Alternative: Imputation nach Breiman:

ds2_imputed <- rfImpute(train2$Sepsis ~ ., train2) %>% 
  dplyr::rename(Sepsis = `train2$Sepsis`) %>% 
  relocate(Sepsis, .after = ICULOS) 
  
rf_ds2 <- train(x = ds2_imputed[,4:41],
                  y = train2$Sepsis,
                  method = "rf",
                  tuneGrid = mtry_grid,
                  metric = "ROC",
                  trControl = ctrl)

rf_ds2

# Hier werden Tetsdaten nicht automatisch imputiert
pred_rf_ds2 <- predict(rf_ds2$finalModel, rfImpute(Sepsis ~., test2)[,-1], type = "class")
confusionMatrix(data = pred_rf_ds2, reference = test2$Sepsis, positive = "positiv")
```
```{r caret rf models ds3, include = TRUE, cache = FALSE}
set.seed(12345)

rf_proc_ds3 <- train(x = train3[,3:40],
                  y = train3$Sepsis,
                  preProcess = "medianImpute",
                  method = "rpart",
#                 tuneGrid = cp_grid,
                  metric = "ROC",
                  trControl = ctrl)

rf_proc_ds3

#Medianimputation der Testdaten findet automatisch statt
pred_rf_proc_ds3 <- predict(rf_proc_ds3$finalModel, test3, type = "class")
confusionMatrix(data = pred_rf_proc_ds3, reference = test3$Sepsis, 
                positive = "positiv")

# Alternative: Imputation nach Breiman:

ds3_imputed <- rfImpute(train3$Sepsis ~ ., train3) %>% 
  dplyr::rename(Sepsis = `train3$Sepsis`)
  
rf_ds3 <- train(x = ds3_imputed[,3:40],
                  y = train3$Sepsis,
                  method = "rf",
                  tuneGrid = mtry_grid,
                  metric = "ROC",
                  trControl = ctrl)

rf_ds3

# Hier werden Tetsdaten nicht automatisch imputiert
pred_rf_ds3 <- predict(rf_ds3$finalModel, rfImpute(Sepsis ~., test3)[,-1], type = "class")
confusionMatrix(data = pred_rf_ds3, reference = test3$Sepsis, positive = "positiv")
```

Medianimputation liefert bessere Ergebnisse als die RandomForest-Imputationsmethode. 
Somit gibt es keinen Grund, die rechenintensivere Methode zu wählen. 
```{r evaluation rf}
confusionMatrix(data = pred_rf_proc_ds1, reference = test1$Sepsis, positive = "positiv")
confusionMatrix(data = pred_rf_ds1, reference = test1$Sepsis, positive = "positiv")
confusionMatrix(data = pred_rf_proc_ds2, reference = test2$Sepsis, positive = "positiv")
confusionMatrix(data = pred_rf_ds2, reference = test2$Sepsis, positive = "positiv")
confusionMatrix(data = pred_rf_proc_ds3, reference = test3$Sepsis, positive = "positiv")
confusionMatrix(data = pred_rf_ds3, reference = test3$Sepsis, positive = "positiv")
```
Dataset 3 (Slopes) mit Medianimput liefert die besten Ergebnisse.

Als Alternative soll aber versucht werden, nur die Variablen mit relativ wenig fehlenden Werten (< 30%) als Prädiktoren zu verwenden und dann nur vollständige Beobachtungen einzubeziehen.
Frage: Vollständig heißt, dass in keinem Prädiktor der Wert fehlt. -> Wie groß ist dann das verbleibende Dataset? Das kann wesentlich kleiner als 70% sein. -> Prüfen.

```{r rf non-missing ds1}
set.seed(12345)

vis_miss(dataset1)
miss_var_summary(dataset1)

train1_2 <- train1 %>% 
  select(Resp, SBP, MAP,	O2Sat, HR, Age,	Gender,	HospAdmTime, ICULOS)

rf_nm_ds1 <- train(x = train1_2,
                  y = train1$Sepsis,
                  method = "rpart",
                  na.action = na.omit,
#                 tuneGrid = cp_grid,
                  metric = "ROC",
                  trControl = ctrl)

rf_nm_ds1

pred_rf_nm_ds1 <- predict(rf_nm_ds1$finalModel, test1, type = "class")
confusionMatrix(data = pred_rf_nm_ds1, reference = test1$Sepsis, positive = "positiv")
```
```{r rf non-missing ds2}
set.seed(12345)

vis_miss(dataset2)
miss_var_summary(dataset2)

train2_2 <- train2 %>% 
  select(WBC, Platelets, Creatinine, BUN, Hct,Potassium,	Glucose, Resp, SBP, O2Sat,
         MAP, HR, Temp, Age, Gender, HospAdmTime)

rf_nm_ds2 <- train(x = train2_2,
                  y = train2$Sepsis,
                  method = "rpart",
                  na.action = na.omit,
#                 tuneGrid = cp_grid,
                  metric = "ROC",
                  trControl = ctrl)

rf_nm_ds2

pred_rf_nm_ds2 <- predict(rf_nm_ds2$finalModel, test2, type = "class")
confusionMatrix(data = pred_rf_nm_ds2, reference = test2$Sepsis, positive = "positiv")
```

```{r rf non-missing ds3}
set.seed(12345)

vis_miss(dataset3)
miss_var_summary(dataset3)

train3_2 <- train3 %>% 
  select(slope_DBP, slope_Calcium, slope_Magnesium, slope_WBC, slope_Platelets,
         slope_Hct, slope_Creatinine, slope_BUN, slope_Potassium, slope_Glucose,
         slope_Temp, slope_SBP, slope_MAP, slope_Resp, slope_O2Sat, slope_HR, Age,
         Gender, HospAdmTime, ICULOS)

rf_nm_ds3 <- train(x = train3_2,
                  y = train3$Sepsis,
                  method = "rpart",
                  na.action = na.omit,
#                 tuneGrid = cp_grid,
                  metric = "ROC",
                  trControl = ctrl)

rf_nm_ds3

pred_rf_nm_ds3 <- predict(rf_nm_ds3$finalModel, test3, type = "class")
confusionMatrix(data = pred_rf_nm_ds3, reference = test3$Sepsis, positive = "positiv")
```

```{r vars description, include = TRUE, echo = FALSE, cache = TRUE}
knitr::kable(var_info, booktabs = T,
             caption = "Datensatzbeschreibung (Variablen)") %>%
  kable_styling(latex_options = c("striped", "scale_down"),
                position = "center")
```